---
title: "二维码扫描系统教程（四）：项目实战与进阶"
date: 2026-02-11
draft: false
weight: 4
tags: ["Python", "Flask", "OpenCV", "项目实战", "部署", "教程"]
categories: ["技术教程"]
description: "完整的项目实战教程，从代码详解到部署运行，包含多线程编程、视频流传输、WebSocket实时推送等高级主题。"
---

# 二维码扫描系统 - 零基础完整教程

## 第四部分：项目实战与进阶

---

## 第十三章：项目完整代码详解

### 13.1 项目架构回顾

```
┌─────────────────────────────────────────────────────────────┐
│                      系统架构图                          │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  浏览器 (Web Client)                                       │
│  ┌──────────┐  ┌──────────┐  ┌──────────────────────┐    │
│  │ 视频流   │  │ 检测结果 │  │   控制按钮          │    │
│  │ 显示     │  │ 显示     │  │   (开始/停止)       │    │
│  └──────────┘  └──────────┘  └──────────────────────┘    │
│         │              │              │                      │
│         └──────────────┴──────────────┘                      │
│                        │                                   │
│                   HTTP/AJAX                                │
│                        │                                   │
├────────────────────────│───────────────────────────────────┤
│                        ↓                                   │
│  Flask Web 服务器                                        │
│  ┌──────────────────────────────────────────────────────┐  │
│  │ 路由处理:                                          │  │
│  │  - /             → index.html                       │  │
│  │  - /video_feed  → 视频流 (MJPEG)                   │  │
│  │  - /api/stats   → 统计数据 (JSON)                  │  │
│  │  - /api/control/start,stop → 控制接口              │  │
│  └──────────────────────────────────────────────────────┘  │
│                        │                                   │
├────────────────────────│───────────────────────────────────┤
│                        ↓                                   │
│  QRScannerServer 核心类                                   │
│  ┌──────────────────────────────────────────────────────┐  │
│  │ 后台线程:                                          │  │
│  │  1. 读取摄像头帧 → cv2.VideoCapture                │  │
│  │  2. 识别二维码   → pyzbar.decode                  │  │
│  │  3. 估算位置     → estimate_qr_position()        │  │
│  │  4. 绘制结果     → draw_detections()             │  │
│  │  5. 更新帧       → self.frame                    │  │
│  └──────────────────────────────────────────────────────┘  │
│                        │                                   │
├────────────────────────│───────────────────────────────────┤
│                        ↓                                   │
│  摄像头硬件 (USB Camera)                                  │
│  /dev/video0, /dev/video1, ...                            │
└─────────────────────────────────────────────────────────────┘
```

### 13.2 完整代码解析

#### 13.2.1 导入和配置

```python
#!/usr/bin/env python3
"""
Intel RealSense D435i QR Code Scanner - Simplified Web Server
使用OpenCV/USB访问 - 无需RealSense SDK Python绑定
"""

# 标准库导入
import threading      # 多线程支持
import logging       # 日志记录
from datetime import datetime  # 时间处理
from collections import deque    # 双端队列

# 第三方库导入
import cv2          # OpenCV图像处理
import numpy as np   # 数值计算
from pyzbar.pyzbar import decode  # 二维码识别

# Flask Web框架
from flask import Flask, render_template, Response, jsonify
from flask_cors import CORS  # 跨域支持

# 配置日志
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)
```

**为什么需要这些导入？**

| 库名 | 用途 |
|------|------|
| cv2 | 读取摄像头、处理图像、绘制文字 |
| numpy | 数学计算、数组操作 |
| pyzbar | 识别和解码二维码 |
| Flask | 创建Web服务器 |
| threading | 后台处理摄像头，不阻塞Web服务 |

#### 13.2.2 QRScannerServer类（初始化）

```python
class QRScannerServer:
    """二维码扫描服务器类"""

    def __init__(self, width=640, height=480, fps=30,
                 camera_id=0, max_history=100, qr_size=0.05):
        """
        初始化QR扫描服务器

        参数:
            width: 视频宽度（像素）
            height: 视频高度（像素）
            fps: 帧率
            camera_id: 摄像头设备ID
            max_history: 最大历史记录数
            qr_size: 二维码物理尺寸（米），默认5cm
        """

        # === 视频参数 ===
        self.width = width
        self.height = height
        self.fps = fps
        self.camera_id = camera_id

        # === 历史记录参数 ===
        self.max_history = max_history
        self.qr_size = qr_size  # 假设二维码5cm

        # === 摄像头对象 ===
        self.camera = None      # 稍后在initialize_camera()中创建

        # === 运行状态 ===
        self.is_running = False

        # === 当前帧（带线程锁） ===
        self.frame = None
        self.frame_lock = threading.Lock()
        # 为什么要锁？因为视频流线程在读取frame，
        # 同时捕获线程在更新frame，可能产生竞态条件

        # === 检测历史（带线程锁） ===
        self.detection_history = deque(maxlen=max_history)
        self.detection_lock = threading.Lock()

        # === 统计数据 ===
        self.frame_count = 0        # 总帧数
        self.total_detections = 0    # 总检测次数

        # === 相机内参（用于位置估算） ===
        self.focal_length = None     # 焦距
        self.cx = None              # 主点X
        self.cy = None              # 主点Y

        logger.info(
            f"QRScannerServer初始化完成 "
            f"({width}x{height}@{fps}fps, QR尺寸: {qr_size}m)"
        )
```

**关键概念：线程锁**

```python
# 为什么需要锁？

# 场景1：没有锁
frame = None

# 线程A（捕获）
frame = new_frame  # 正在写入...

# 线程B（视频流）
return frame  # 可能读到一半新一半旧！

# 场景2：有锁
frame = None
frame_lock = threading.Lock()

# 线程A
with frame_lock:
    frame = new_frame  # 独占访问

# 线程B
with frame_lock:
    return frame  # 等待A完成后再读

# 锁确保：
# 1. 同一时间只有一个线程访问
# 2. 读取的数据是完整的
# 3. 不会出现数据竞争
```

#### 13.2.3 相机初始化

```python
def initialize_camera(self):
    """使用OpenCV初始化摄像头"""

    try:
        # 创建VideoCapture对象
        # 参数：摄像头索引（0, 1, 2...）
        self.camera = cv2.VideoCapture(self.camera_id)

        # 检查是否成功打开
        if not self.camera.isOpened():
            raise Exception(f"无法打开摄像头 {self.camera_id}")

        # 设置摄像头参数
        self.camera.set(cv2.CAP_PROP_FRAME_WIDTH, self.width)
        self.camera.set(cv2.CAP_PROP_FRAME_HEIGHT, self.height)
        self.camera.set(cv2.CAP_PROP_FPS, self.fps)

        # 获取实际参数（可能和设置的不同）
        actual_width = int(self.camera.get(cv2.CAP_PROP_FRAME_WIDTH))
        actual_height = int(self.camera.get(cv2.CAP_PROP_FRAME_HEIGHT))
        actual_fps = self.camera.get(cv2.CAP_PROP_FPS)

        logger.info(
            f"摄像头已初始化: {actual_width}x{actual_height}@{actual_fps}fps"
        )

        # 估算相机内参
        # 对大多数网络相机，焦距 ≈ 宽度 × 1.2
        self.focal_length = actual_width * 1.2
        self.cx = actual_width / 2.0   # 图像中心X
        self.cy = actual_height / 2.0  # 图像中心Y

        logger.info(
            f"相机内参估算: fx={self.focal_length:.1f}, "
            f"cx={self.cx:.1f}, cy={self.cy:.1f}"
        )

        return True

    except Exception as e:
        logger.error(f"摄像头初始化失败: {e}")
        return False
```

**相机内参说明：**

```
相机内参矩阵：
    [fx   0    cx]
K = [0    fy   cy]
    [0    0    1 ]

fx, fy: 焦距（像素单位）
cx, cy: 主点坐标（光轴与图像平面的交点）

本项目的简化估算：
- fx = width × 1.2（经验公式）
- fy = fx（假设像素是正方形）
- cx = width / 2
- cy = height / 2

更精确的方法：
使用棋盘格进行相机标定
```

#### 13.2.4 位置估算函数

```python
def estimate_qr_position(self, qr_points):
    """
    估算二维码相对于相机的位置

    参数:
        qr_points: 二维码四个角点 [(x1,y1), (x2,y2), (x3,y3), (x4,y4)]

    返回:
        dict: 包含距离、角度、3D坐标的信息
    """

    # 检查输入
    if not qr_points or len(qr_points) < 4:
        return None

    # === 计算二维码中心 ===
    # 四个点的平均值
    center_x = sum(p[0] for p in qr_points) / 4.0
    center_y = sum(p[1] for p in qr_points) / 4.0

    # === 计算二维码在图像中的尺寸 ===
    # 将点转为numpy数组便于计算
    p0 = np.array(qr_points[0])
    p1 = np.array(qr_points[1])
    p2 = np.array(qr_points[2])
    p3 = np.array(qr_points[3])

    # 计算边长（欧几里得距离）
    width_pixel = np.linalg.norm(p0 - p1)   # ||p0 - p1||
    height_pixel = np.linalg.norm(p1 - p2)  # ||p1 - p2||
    avg_size_pixel = (width_pixel + height_pixel) / 2.0

    # 检查有效性
    if avg_size_pixel < 1:
        return None  # 太小，无效

    # === 使用相似三角形计算距离 ===
    # d = f × h / s
    # d: 距离（未知）
    # f: 焦距（已知）
    # h: 二维码真实尺寸（已知）
    # s: 像素尺寸（测量得到）
    distance = (self.qr_size * self.focal_length) / avg_size_pixel

    # === 计算角度 ===
    dx = center_x - self.cx  # X方向偏移
    dy = center_y - self.cy  # Y方向偏移

    # arctan2计算角度（弧度）
    horizontal_angle = np.arctan2(dx, self.focal_length)
    vertical_angle = np.arctan2(dy, self.focal_length)

    # 转换为角度
    h_angle_deg = np.degrees(horizontal_angle)
    v_angle_deg = np.degrees(vertical_angle)

    # === 估算3D坐标 ===
    # 相机坐标系：X右，Y下，Z前
    x = distance * np.tan(horizontal_angle)
    y = distance * np.tan(vertical_angle)
    z = distance

    # === 返回完整信息 ===
    return {
        'distance': distance,              # 距离（米）
        'horizontal_angle': h_angle_deg,    # 水平角（度）
        'vertical_angle': v_angle_deg,     # 垂直角（度）
        'x': x, 'y': y, 'z': z,        # 3D坐标（米）
        'center_x': center_x,             # 图像中X坐标
        'center_y': center_y,             # 图像中Y坐标
        'qr_size_pixel': avg_size_pixel   # 像素尺寸
    }
```

#### 13.2.5 二维码解码函数

```python
def decode_qr_codes(self, frame):
    """
    检测并解码图像中的二维码（带位置估算）

    参数:
        frame: OpenCV图像（BGR格式）

    返回:
        list: 检测结果列表
    """

    results = []

    # 转换为RGB（pyzbar需要RGB格式）
    rgb_frame = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)

    # 解码所有条码/二维码
    barcodes = decode(rgb_frame)

    for barcode in barcodes:
        # 获取条码数据
        data = barcode.data.decode('utf-8')
        barcode_type = barcode.type

        # 获取四个角点
        pts = [(pt.x, pt.y) for pt in barcode.polygon]

        # 估算位置
        position = None
        if self.focal_length is not None:
            position = self.estimate_qr_position(pts)

        # 构建检测结果
        detection = {
            'type': barcode_type,
            'data': data,
            'points': pts,
            'position': position,
            'timestamp': datetime.now().isoformat()
        }

        results.append(detection)

        # 记录日志
        if position:
            logger.info(
                f"[QR] {barcode_type}: {data} | "
                f"距离: {position['distance']:.2f}m | "
                f"H: {position['horizontal_angle']:.1f}° | "
                f"V: {position['vertical_angle']:.1f}°"
            )
        else:
            logger.info(f"[QR] {barcode_type}: {data}")

        # 更新统计
        self.total_detections += 1

    return results
```

#### 13.2.6 绘制检测结果

```python
def draw_detections(self, frame, detections):
    """
    在图像上绘制检测结果和位置信息

    参数:
        frame: 原始图像
        detections: 检测结果列表

    返回:
        output: 标注后的图像
    """

    # 复制图像（不修改原图）
    output = frame.copy()

    # 文字起始Y坐标
    y_offset = 30

    for detection in detections:
        # === 绘制多边形 ===
        pts = np.array(detection['points'], np.int32)
        pts = pts.reshape((-1, 1, 2))
        cv2.polylines(output, [pts], True, (0, 255, 0), 2)

        # === 绘制起点 ===
        if detection['points']:
            pt = detection['points'][0]
            cv2.circle(output, tuple(pt), 5, (0, 255, 0), -1)

            # === 绘制中心点 ===
            if detection.get('position'):
                center = detection['position']
                cx = int(center['center_x'])
                cy = int(center['center_y'])

                # 蓝色实心圆
                cv2.circle(output, (cx, cy), 8, (255, 0, 0), -1)
                # 白色空心圆
                cv2.circle(output, (cx, cy), 10, (255, 255, 255), 1)

        # === 绘制类型和数据 ===
        text = f"{detection['type']}: {detection['data'][:25]}"
        cv2.putText(output, text, (10, y_offset),
                   cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0, 255, 0), 2)
        y_offset += 20

        # === 绘制位置信息 ===
        if detection.get('position'):
            pos = detection['position']

            # 信息行
            info_lines = [
                f"距离: {pos['distance']:.2f}m",
                f"水平角: {pos['horizontal_angle']:.1f}°",
                f"垂直角: {pos['vertical_angle']:.1f}°",
                f"位置: ({pos['x']:.2f}, {pos['y']:.2f}, {pos['z']:.2f})m"
            ]

            for line in info_lines:
                cv2.putText(output, line, (10, y_offset),
                           cv2.FONT_HERSHEY_SIMPLEX, 0.4, (255, 200, 0), 1)
                y_offset += 18

            # === 绘制方向指示箭头 ===
            cx, cy = self.cx, self.cy
            qx, qy = pos['center_x'], pos['center_y']

            # 从图像中心画到二维码中心
            cv2.arrowedLine(output, (int(cx), int(cy)), (int(qx), int(qy)),
                           (255, 255, 0), 2, tipLength=0.2)

        # 额外间距
        y_offset += 10

    # === 绘制帧信息 ===
    info_text = f"帧数: {self.frame_count} | 检测: {self.total_detections}"
    cv2.putText(output, info_text, (10, self.height - 20),
               cv2.FONT_HERSHEY_SIMPLEX, 0.5, (255, 255, 255), 1)

    # === 绘制相机信息 ===
    if self.focal_length:
        param_text = f"f: {self.focal_length:.0f}px | QR尺寸: {self.qr_size}m"
        cv2.putText(output, param_text, (10, self.height - 40),
                   cv2.FONT_HERSHEY_SIMPLEX, 0.4, (200, 200, 200), 1)

    return output
```

#### 13.2.7 帧捕获循环

```python
def capture_frames(self):
    """在独立线程中捕获摄像头帧"""

    # 初始化摄像头
    if not self.initialize_camera():
        logger.error("无法初始化摄像头")
        return

    self.is_running = True
    logger.info("帧捕获线程已启动")

    try:
        while self.is_running:
            # 读取一帧
            ret, frame = self.camera.read()

            if not ret:
                logger.warning("从摄像头读取帧失败")
                continue

            # 更新帧计数
            self.frame_count += 1

            # === 检测二维码 ===
            detections = self.decode_qr_codes(frame)

            # === 保存到历史记录 ===
            if detections:
                with self.detection_lock:
                    for detection in detections:
                        self.detection_history.append(detection)

            # === 绘制检测结果 ===
            output_frame = self.draw_detections(frame, detections)

            # === 更新当前帧（带锁） ===
            with self.frame_lock:
                self.frame = output_frame

    except Exception as e:
        logger.error(f"帧捕获错误: {e}")

    finally:
        # 清理资源
        if self.camera:
            self.camera.release()
        self.is_running = False
        logger.info("帧捕获线程已停止")
```

#### 13.2.8 视频流生成器

```python
def get_frame_generator(self):
    """
    生成MJPEG格式的视频流

    MJPEG格式：
    --boundary\r\n
    Content-Type: image/jpeg\r\n
    Content-Length: xxxxx\r\n
    \r\n
    [JPEG数据]\r\n
    --boundary\r\n
    ...

    浏览器接收后连续播放形成视频
    """

    while self.is_running:
        # 读取当前帧（带锁）
        with self.frame_lock:
            if self.frame is None:
                continue  # 还没有帧

            # 编码为JPEG
            # 质量：80（0-100，越大质量越高）
            ret, buffer = cv2.imencode(
                '.jpg', self.frame,
                [cv2.IMWRITE_JPEG_QUALITY, 80]
            )

        if ret:
            # 转为字节
            frame_bytes = buffer.tobytes()

            # 生成MJPEG格式的响应
            yield (
                b'--frame\r\n'
                b'Content-Type: image/jpeg\r\n'
                b'Content-Length: ' + str(len(frame_bytes)).encode() + b'\r\n\r\n' +
                frame_bytes + b'\r\n'
            )
```

### 13.3 前端JavaScript详解

#### 13.3.1 ScannerClient类

```javascript
/**
 * QR扫描器客户端类
 * 负责与后端通信和UI更新
 */
class ScannerClient {
    constructor() {
        // === 状态变量 ===
        this.isRunning = false;           // 扫描器是否运行
        this.statsUpdateInterval = null;  // 统计更新定时器
        this.healthCheckInterval = null;   // 健康检查定时器
        this.detectionCache = new Map();  // 检测缓存

        // === 初始化 ===
        this.initializeElements();    // 获取DOM元素
        this.attachEventListeners(); // 绑定事件
        this.startHealthCheck();     // 启动健康检查
        this.startStatsUpdate();     // 启动统计更新
        this.updateTime();          // 启动时间更新
    }

    // 获取DOM元素
    initializeElements() {
        this.btnStart = document.getElementById('btnStart');
        this.btnStop = document.getElementById('btnStop');
        this.statusDot = document.getElementById('statusDot');
        this.statusText = document.getElementById('statusText');
        this.frameCounter = document.getElementById('frameCounter');
        this.detectionCounter = document.getElementById('detectionCounter');
        this.footerTime = document.getElementById('footerTime');
        this.statFrames = document.getElementById('statFrames');
        this.statDetections = document.getElementById('statDetections');
        this.statUnique = document.getElementById('statUnique');
        this.recentList = document.getElementById('recentList');
        this.historyBody = document.getElementById('historyBody');
        this.historyCount = document.getElementById('historyCount');
        this.btnClearHistory = document.getElementById('btnClearHistory');
    }

    // 绑定事件监听器
    attachEventListeners() {
        this.btnStart.addEventListener('click', () => this.startScanning());
        this.btnStop.addEventListener('click', () => this.stopScanning());
        this.btnClearHistory.addEventListener('click', () => this.clearHistory());
    }

    // 启动扫描
    async startScanning() {
        try {
            const response = await fetch('/api/control/start', {
                method: 'POST'
            });
            const data = await response.json();

            if (data.status === 'started') {
                this.isRunning = true;
                this.updateControlButtons();
                this.showNotification('扫描器已启动', 'success');
            }
        } catch (error) {
            console.error('启动扫描器失败:', error);
            this.showNotification('启动扫描器失败', 'error');
        }
    }

    // 停止扫描
    async stopScanning() {
        try {
            const response = await fetch('/api/control/stop', {
                method: 'POST'
            });
            const data = await response.json();

            if (data.status === 'stopped') {
                this.isRunning = false;
                this.updateControlButtons();
                this.showNotification('扫描器已停止', 'warning');
            }
        } catch (error) {
            console.error('停止扫描器失败:', error);
            this.showNotification('停止扫描器失败', 'error');
        }
    }

    // 更新控制按钮状态
    updateControlButtons() {
        this.btnStart.disabled = this.isRunning;
        this.btnStop.disabled = !this.isRunning;

        if (this.isRunning) {
            this.statusDot.className = 'status-dot active';
            this.statusText.textContent = '运行中';
        } else {
            this.statusDot.className = 'status-dot inactive';
            this.statusText.textContent = '空闲';
        }
    }

    // 健康检查
    async healthCheck() {
        try {
            const response = await fetch('/api/health');
            const data = await response.json();
            return data.scanner_running;
        } catch (error) {
            console.warn('健康检查失败:', error);
            return false;
        }
    }

    // 启动健康检查（每5秒）
    startHealthCheck() {
        this.healthCheckInterval = setInterval(async () => {
            const isRunning = await this.healthCheck();
            this.isRunning = isRunning;
            this.updateControlButtons();
        }, 5000);
    }

    // 获取并更新统计信息
    async updateStats() {
        try {
            const response = await fetch('/api/stats');
            const stats = await response.json();

            // 更新计数器
            this.frameCounter.textContent = `帧: ${stats.frame_count}`;
            this.detectionCounter.textContent = `QR: ${stats.total_detections}`;

            // 更新统计面板
            this.statFrames.textContent = stats.frame_count;
            this.statDetections.textContent = stats.total_detections;
            this.statUnique.textContent = stats.unique_codes;

            // 更新最近检测列表
            this.updateRecentDetections(stats.recent_detections);

            // 更新历史表格
            this.updateHistoryTable(stats.codes);

        } catch (error) {
            console.error('获取统计信息失败:', error);
        }
    }

    // 启动统计更新（每1秒）
    startStatsUpdate() {
        this.updateStats();  // 立即执行一次
        this.statsUpdateInterval = setInterval(() => {
            this.updateStats();
        }, 1000);
    }

    // 更新最近检测列表
    updateRecentDetections(detections) {
        if (!detections || detections.length === 0) {
            if (this.recentList.children.length === 0 ||
                !this.recentList.querySelector('.placeholder')) {
                this.recentList.innerHTML =
                    '<p class="placeholder">等待检测...</p>';
            }
            return;
        }

        // 移除占位符
        const placeholder = this.recentList.querySelector('.placeholder');
        if (placeholder) {
            placeholder.remove();
        }

        // 只保留最新的10条
        const latestDetections = detections.slice(-10).reverse();

        latestDetections.forEach(detection => {
            // 创建唯一键（避免重复显示）
            const key = `${detection.type}_${detection.data}_${detection.timestamp}`;

            if (!this.detectionCache.has(key)) {
                const item = document.createElement('div');
                item.className = 'recent-item';

                const timestamp = new Date(detection.timestamp).toLocaleTimeString();

                // 构建位置信息HTML
                let positionHtml = '';
                if (detection.position) {
                    const pos = detection.position;
                    positionHtml = `
                        <div class="recent-item-position">
                            <div class="position-row">
                                <span class="position-label">距离:</span>
                                <span class="position-value">${pos.distance.toFixed(2)}m</span>
                            </div>
                            <div class="position-row">
                                <span class="position-label">水平角:</span>
                                <span class="position-value">${pos.horizontal_angle.toFixed(1)}°</span>
                            </div>
                            <div class="position-row">
                                <span class="position-label">垂直角:</span>
                                <span class="position-value">${pos.vertical_angle.toFixed(1)}°</span>
                            </div>
                            <div class="position-row position-3d">
                                <span class="position-label">3D:</span>
                                <span class="position-value">(${pos.x.toFixed(2)}, ${pos.y.toFixed(2)}, ${pos.z.toFixed(2)})</span>
                            </div>
                        </div>
                    `;
                }

                item.innerHTML = `
                    <div class="recent-item-type">${detection.type}</div>
                    <div class="recent-item-data">${this.truncateText(detection.data, 40)}</div>
                    ${positionHtml}
                    <div class="recent-item-time">${timestamp}</div>
                `;

                // 插入到列表顶部
                this.recentList.insertBefore(item, this.recentList.firstChild);
                this.detectionCache.set(key, true);
            }
        });

        // 移除旧项（最多保留20条）
        while (this.recentList.children.length > 20) {
            this.recentList.removeChild(this.recentList.lastChild);
        }
    }

    // 更新历史表格
    updateHistoryTable(codes) {
        if (!codes || codes.length === 0) {
            this.historyBody.innerHTML =
                '<tr><td colspan="4" class="empty">暂无历史记录</td></tr>';
            this.historyCount.textContent = '0 个码';
            return;
        }

        this.historyBody.innerHTML = '';

        codes.forEach(([data, info]) => {
            const row = document.createElement('tr');
            const timestamp = new Date().toLocaleTimeString();

            row.innerHTML = `
                <td>${info.type}</td>
                <td><code>${this.truncateText(data, 50)}</code></td>
                <td><strong>${info.count}</strong></td>
                <td>${timestamp}</td>
            `;

            this.historyBody.appendChild(row);
        });

        this.historyCount.textContent = `${codes.length} 个码`;
    }

    // 清除历史
    clearHistory() {
        if (confirm('确定要清除历史记录吗？')) {
            this.detectionCache.clear();
            this.recentList.innerHTML = '<p class="placeholder">历史已清除</p>';
            this.historyBody.innerHTML =
                '<tr><td colspan="4" class="empty">无历史记录</td></tr>';
            this.historyCount.textContent = '0 个码';
        }
    }

    // 更新页脚时间
    updateTime() {
        const now = new Date();
        this.footerTime.textContent = now.toLocaleTimeString();
        setTimeout(() => this.updateTime(), 1000);
    }

    // 截断文本
    truncateText(text, maxLength) {
        if (text.length > maxLength) {
            return text.substring(0, maxLength) + '...';
        }
        return text;
    }

    // 显示通知
    showNotification(message, type) {
        console.log(`[${type.toUpperCase()}] ${message}`);
    }

    // 清理资源
    destroy() {
        if (this.statsUpdateInterval) clearInterval(this.statsUpdateInterval);
        if (this.healthCheckInterval) clearInterval(this.healthCheckInterval);
    }
}

// 初始化
let client;
document.addEventListener('DOMContentLoaded', () => {
    client = new ScannerClient();
    console.log('QR扫描器客户端已初始化');
});

// 页面卸载时清理
window.addEventListener('beforeunload', () => {
    if (client) {
        client.destroy();
    }
});
```

---

## 第十四章：部署与运行

### 14.1 环境准备

#### 14.1.1 系统要求

```
硬件要求：
- CPU: 双核及以上
- 内存: 2GB及以上
- 摄像头: USB摄像头（支持UVC）

软件要求：
- 操作系统: Linux / Windows / Mac
- Python: 3.8及以上
- 浏览器: Chrome / Firefox / Safari
```

#### 14.1.2 依赖安装

```bash
# 1. 创建虚拟环境
python3 -m venv venv
source venv/bin/activate  # Linux/Mac
# 或
venv\Scripts\activate  # Windows

# 2. 安装Python依赖
pip install opencv-python pyzbar flask flask-cors

# 3. Linux系统可能需要安装系统库
sudo apt-get install python3-dev
sudo apt-get install libzbar0
```

### 14.2 运行项目

#### 14.2.1 基本运行

```bash
# 激活虚拟环境
source venv/bin/activate

# 运行服务器（使用默认参数）
python3 qr_scanner_server_simple.py

# 输出示例：
# QRScannerServer initialized (640x480@30fps, QR size: 0.05m)
# Camera initialized: 640x480@30fps
# Frame capture thread started
#  * Running on http://0.0.0.0:5000
```

#### 14.2.2 自定义参数

```bash
# 指定摄像头ID
python3 qr_scanner_server_simple.py --camera 1

# 指定分辨率
python3 qr_scanner_server_simple.py --width 1280 --height 720

# 指定二维码尺寸（重要！影响距离计算精度）
python3 qr_scanner_server_simple.py --qr-size 0.08  # 8cm

# 指定端口
python3 qr_scanner_server_simple.py --port 8080

# 组合使用
python3 qr_scanner_server_simple.py \
    --camera 1 \
    --width 1280 \
    --height 720 \
    --qr-size 0.05 \
    --port 5000
```

### 14.3 常见问题解决

#### 14.3.1 摄像头无法打开

```bash
# 问题：Cannot open camera
# 解决：

# 1. 检查摄像头设备
ls -la /dev/video*

# 2. 检查权限
sudo chmod 666 /dev/video0

# 3. 尝试不同的摄像头ID
python3 qr_scanner_server_simple.py --camera 0
python3 qr_scanner_server_simple.py --camera 1
```

#### 14.3.2 视频流显示黑屏

```bash
# 可能原因和解决方案：

# 1. 摄像头被其他程序占用
# 解决：关闭其他使用摄像头的程序

# 2. 摄像头ID错误
# 解决：尝试不同的camera ID

# 3. 分辨率不支持
# 解决：降低分辨率
python3 qr_scanner_server_simple.py --width 640 --height 480
```

#### 14.3.3 二维码识别不工作

```python
# 可能原因和解决方案：

# 1. pyzbar未安装
pip install pyzbar

# 2. 系统库缺失
sudo apt-get install libzbar0

# 3. 图像质量问题
# 解决：改善光照条件
#        调整摄像头焦距
#        使用高分辨率摄像头

# 4. 二维码尺寸设置错误
# 解决：测量实际二维码尺寸，设置--qr-size参数
```

---

## 第十五章：项目扩展与进阶

### 15.1 添加声音提示

```python
# 在qr_scanner_server_simple.py中添加

import pygame

class QRScannerServer:
    def __init__(self, ...):
        # ...
        self.last_detection_time = None
        self.init_sound()

    def init_sound(self):
        """初始化声音系统"""
        try:
            pygame.mixer.init()
            # 生成提示音
            self.create_beep()
            logger.info("声音系统初始化成功")
        except Exception as e:
            logger.warning(f"声音系统初始化失败: {e}")

    def create_beep(self):
        """生成提示音"""
        sample_rate = 44100
        duration = 0.1  # 100ms
        frequency = 880  # A5音符

        # 生成正弦波
        t = np.linspace(0, duration, int(sample_rate * duration))
        wave = np.sin(2 * np.pi * frequency * t)

        # 转换为16位整数
        wave = (wave * 32767).astype(np.int16)

        # 创建立体声
        stereo = np.column_stack((wave, wave))

        # 保存为WAV文件
        import soundfile as sf
        sf.write('beep.wav', stereo, sample_rate)

    def play_beep(self):
        """播放提示音"""
        try:
            pygame.mixer.music.load('beep.wav')
            pygame.mixer.music.play()
        except:
            pass

    def decode_qr_codes(self, frame):
        """检测二维码并播放提示音"""
        results = []

        # ... 原有检测代码 ...

        # 如果检测到新二维码，播放提示音
        if results:
            current_time = datetime.now()
            if (self.last_detection_time is None or
                (current_time - self.last_detection_time).total_seconds() > 1):
                self.play_beep()
                self.last_detection_time = current_time

        return results
```

### 15.2 数据库存储

```python
# 添加SQLite数据库支持

import sqlite3
from contextlib import contextmanager

class DatabaseManager:
    """数据库管理器"""

    def __init__(self, db_path='detections.db'):
        self.db_path = db_path
        self.init_database()

    @contextmanager
    def get_connection(self):
        """获取数据库连接（上下文管理器）"""
        conn = sqlite3.connect(self.db_path)
        conn.row_factory = sqlite3.Row
        try:
            yield conn
            conn.commit()
        except Exception as e:
            conn.rollback()
            raise e
        finally:
            conn.close()

    def init_database(self):
        """初始化数据库表"""
        with self.get_connection() as conn:
            conn.execute('''
                CREATE TABLE IF NOT EXISTS detections (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    type TEXT NOT NULL,
                    data TEXT NOT NULL,
                    distance REAL,
                    horizontal_angle REAL,
                    vertical_angle REAL,
                    x REAL,
                    y REAL,
                    z REAL,
                    timestamp TEXT NOT NULL,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )
            ''')

            # 创建索引
            conn.execute('''
                CREATE INDEX IF NOT EXISTS idx_data
                ON detections(data)
            ''')
            conn.execute('''
                CREATE INDEX IF NOT EXISTS idx_timestamp
                ON detections(timestamp)
            ''')

    def save_detection(self, detection):
        """保存检测结果"""
        with self.get_connection() as conn:
            position = detection.get('position', {})
            conn.execute('''
                INSERT INTO detections (
                    type, data, distance, horizontal_angle,
                    vertical_angle, x, y, z, timestamp
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
            ''', (
                detection['type'],
                detection['data'],
                position.get('distance'),
                position.get('horizontal_angle'),
                position.get('vertical_angle'),
                position.get('x'),
                position.get('y'),
                position.get('z'),
                detection['timestamp']
            ))

    def get_statistics(self):
        """获取统计信息"""
        with self.get_connection() as conn:
            # 总检测次数
            total = conn.execute(
                'SELECT COUNT(*) FROM detections'
            ).fetchone()[0]

            # 唯一二维码数
            unique = conn.execute(
                'SELECT COUNT(DISTINCT data) FROM detections'
            ).fetchone()[0]

            # 最近检测
            recent = conn.execute('''
                SELECT * FROM detections
                ORDER BY timestamp DESC
                LIMIT 10
            ''').fetchall()

            return {
                'total': total,
                'unique': unique,
                'recent': [dict(row) for row in recent]
            }

# 在主程序中使用
db = DatabaseManager()

# 在decode_qr_codes中保存
for detection in results:
    db.save_detection(detection)

# 添加API端点
@app.route('/api/history')
def api_history():
    """获取历史记录"""
    stats = db.get_statistics()
    return jsonify(stats)
```

### 15.3 多摄像头支持

```python
# 支持多个摄像头

class MultiCameraScanner:
    """多摄像头扫描器"""

    def __init__(self, camera_ids=[0, 1]):
        self.camera_ids = camera_ids
        self.scanners = {}

        # 为每个摄像头创建扫描器
        for cam_id in camera_ids:
            self.scanners[cam_id] = QRScannerServer(
                camera_id=cam_id
            )

    def start_all(self):
        """启动所有扫描器"""
        for cam_id, scanner in self.scanners.items():
            scanner.start()
            logger.info(f"摄像头 {cam_id} 已启动")

    def get_combined_stats(self):
        """获取合并的统计信息"""
        combined = {
            'scanners': {},
            'total_frames': 0,
            'total_detections': 0
        }

        for cam_id, scanner in self.scanners.items():
            stats = scanner.get_stats()
            combined['scanners'][cam_id] = stats
            combined['total_frames'] += stats['frame_count']
            combined['total_detections'] += stats['total_detections']

        return combined

# 添加多视图API
@app.route('/video_feed/<int:camera_id>')
def video_feed_camera(camera_id):
    """指定摄像头的视频流"""
    scanner = multi_scanner.scanners.get(camera_id)
    if scanner is None:
        return "Camera not found", 404

    return Response(
        scanner.get_frame_generator(),
        mimetype='multipart/x-mixed-replace; boundary=frame'
    )
```

### 15.4 WebSocket实时推送

```python
# 使用WebSocket实时推送检测结果

from flask_socketio import SocketIO, emit
from flask import request

app = Flask(__name__)
socketio = SocketIO(app, cors_allowed_origins="*")

@socketio.on('connect')
def handle_connect():
    """客户端连接"""
    print(f'客户端已连接: {request.sid}')
    emit('connected', {'status': 'connected'})

@socketio.on('disconnect')
def handle_disconnect():
    """客户端断开"""
    print(f'客户端已断开: {request.sid}')

def broadcast_detection(detection):
    """广播检测结果给所有客户端"""
    socketio.emit('detection', detection, broadcast=True)

# 在decode_qr_codes中调用
for detection in results:
    broadcast_detection(detection)

# 前端JavaScript
const socket = io();

socket.on('connect', () => {
    console.log('已连接到服务器');
});

socket.on('detection', (detection) => {
    console.log('收到检测结果:', detection);
    // 实时更新UI
    displayDetection(detection);
});

# 替代轮询方式
```

---

## 第十六章：学习资源与进阶路径

### 16.1 推荐书籍

**Python基础：**
- 《Python编程：从入门到实践》
- 《流畅的Python》
- 《Python Cookbook》

**Web开发：**
- 《Flask Web开发》
- 《Flask权威指南》

**计算机视觉：**
- 《学习OpenCV 3》
- 《计算机视觉：算法与应用》

### 16.2 在线课程

| 平台 | 课程 |
|------|------|
| Coursera | Python for Everybody |
| edX | CS50's Introduction to Computer Science |
| Udemy | 2024 Complete Python Bootcamp |
| B站 | Python零基础教程 |

### 16.3 进阶学习路径

```
第一阶段（1-2个月）
├── Python基础语法
├── 数据类型和控制流
├── 函数和模块
└── 基本项目练习

第二阶段（2-3个月）
├── Web开发基础（HTML/CSS/JS）
├── Flask框架
├── 数据库操作
└── 本项目完整学习

第三阶段（3-4个月）
├── OpenCV深入学习
├── 计算机视觉算法
├── 机器学习基础
└── 实际项目开发

第四阶段（持续）
├── 深度学习
├── 高级图像处理
├── 系统架构设计
└── 开源贡献
```

### 16.4 实践项目建议

**初级项目：**
1. 图片批量处理工具
2. 简单的待办事项Web应用
3. 天气查询应用

**中级项目：**
1. 人脸识别门禁系统
2. 文档扫描OCR应用
3. 实时物体计数器

**高级项目：**
1. 智能监控分析系统
2. AR导航应用
3. 机器人视觉系统

---

## 全书总结

### 技术栈回顾

```
┌─────────────────────────────────────────────────────────────┐
│                    完整技术栈                          │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  前端技术:                                                │
│    ├── HTML (页面结构)                                    │
│    ├── CSS (样式设计)                                     │
│    └── JavaScript (交互逻辑)                               │
│                                                             │
│  后端技术:                                                │
│    ├── Flask (Web框架)                                    │
│    ├── Python (编程语言)                                   │
│    └── RESTful API (接口设计)                             │
│                                                             │
│  图像处理:                                                │
│    ├── OpenCV (图像处理)                                  │
│    ├── Pyzbar (二维码识别)                                │
│    └── NumPy (数值计算)                                   │
│                                                             │
│  算法原理:                                                │
│    ├── 相似三角形 (距离估算)                               │
│    ├── 三角函数 (角度计算)                                 │
│    └── 图像处理 (滤波、边缘检测)                           │
│                                                             │
│  系统设计:                                                │
│    ├── 多线程编程                                         │
│    ├── 流媒体传输 (MJPEG)                                 │
│    └── 实时数据同步                                      │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 核心知识点

| 类别 | 知识点 | 掌握程度 |
|------|--------|----------|
| Python | 变量、函数、类 | ⭐⭐⭐⭐⭐ |
| Web | HTML/CSS/JS | ⭐⭐⭐⭐ |
| Flask | 路由、模板、API | ⭐⭐⭐⭐ |
| OpenCV | 读取、处理、显示 | ⭐⭐⭐⭐ |
| 算法 | 相似三角形 | ⭐⭐⭐⭐⭐ |
| 线程 | 锁、队列 | ⭐⭐⭐ |

### 学习建议

1. **循序渐进**：不要急于求成，按阶段学习
2. **动手实践**：每学一个知识点就动手写代码
3. **调试能力**：学会使用print和debugger
4. **阅读源码**：多读开源项目的代码
5. **参与社区**：加入技术社区，提问和回答

### 继续学习

- 尝试修改本项目代码
- 添加新功能
- 优化性能
- 部署到云服务器
- 分享给他人使用

---

## 附录A：常见命令速查

### Python命令

```bash
# 运行Python脚本
python3 script.py

# 进入交互式环境
python3

# 安装包
pip install package_name

# 查看已安装包
pip list

# 导出依赖
pip freeze > requirements.txt

# 安装依赖
pip install -r requirements.txt
```

### Git命令

```bash
# 初始化仓库
git init

# 添加文件
git add .

# 提交
git commit -m "message"

# 查看状态
git status

# 查看历史
git log

# 创建分支
git branch branch_name

# 切换分支
git checkout branch_name
```

### Linux命令

```bash
# 列出文件
ls -la

# 进入目录
cd /path/to/dir

# 创建目录
mkdir dirname

# 删除文件
rm file

# 查看文件
cat file

# 搜索文本
grep "pattern" file

# 查看进程
ps aux | grep name

# 杀死进程
kill PID
```

---

## 附录B：调试技巧

### Python调试

```python
# 1. 使用print
print(f"变量值: {variable}")

# 2. 使用logging
import logging
logging.basicConfig(level=logging.DEBUG)
logger = logging.getLogger(__name__)
logger.debug(f"调试信息: {variable}")

# 3. 使用pdb调试器
import pdb; pdb.set_trace()

# 4. 使用IDE断点
# 在PyCharm/VSCode中设置断点
```

### JavaScript调试

```javascript
// 1. 使用console
console.log('调试信息');
console.error('错误信息');
console.table(array);

// 2. 使用debugger
debugger; // 暂停执行

// 3. 使用浏览器开发者工具
// F12打开开发者工具
```

---

*第四部分完成*

## 全书完

**总字数：约70,000字**

涵盖内容：
1. 计算机基础与编程入门
2. Web开发与前端技术
3. Flask框架与图像处理
4. 项目实战与进阶

祝你学习顺利！

---

## 返回阅读：
- [教程01：计算机基础与编程入门](/posts/教程01-计算机基础与编程入门/)
- [教程02：Web开发与前端技术](/posts/教程02-web开发与前端技术/)
- [教程03：Flask框架与图像处理](/posts/教程03-flask框架与图像处理/)
